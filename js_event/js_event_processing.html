<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <div id = 'outside'>
        <input type="checkbox" id ='i1'>
        <label for="">exercise</label>

        <input type="checkbox" id = 'i2'>
        <label for="">shopping</label>

        <input type="checkbox" id = 'i3'>
        <label for="">dining</label>

        <input type="checkbox" id = 'i4'>
        <label for="">sleepping</label>
    </div>

    <script>

      // event delegation, 이벤트 위임!
      // 제일 바깥 쪽에 걸었음에도 불구하고, capture phase로 들어가서 INPUT에서 이벤트가 호출됨!
      // parent or child -> parent에 event를 걸어도 child 확인 가능!
      const cp_div = document.querySelector('#outside');
      // event listner 하나만으로도 아이디로 구별 가능
      cp_div.addEventListener('click', (event)=>{
        // event listner 두 개 걸어야 각각의 이벤트마다 처리 가능
        if (event.target.id == 'i1'){
          console.log('exercise');
        }
        else if (event.target.id == 'i2'){
          console.log('shopping');
        }
        else if (event.target.id == 'i3'){
          console.log('dining');
        }
        else if (event.target.id == 'i4'){
          console.log('sleeping');
        }
      });
      
      cp_div.addEventListener('click', (event)=>{
        console.log('div event processing');
      });
      // const inputs = document.querySelectorAll('input'); // list
      // inputs.forEach((_ip, _idx)=>{
      //   _ip.addEventListener('click', (event)=>{
      //     console.log(_idx + ' bubble phase : input click event occured!');
      //     event.stopPropagation();
      //     // 위로 다시 전달이 되지 않음!, 옆으로 가는 것은 못막음

      //     // 옆으로 가는 것을 막으려면?
      //     event.stopImmediatePropagation();
      //     // 두 번째 이벤트 리스너는 수행이 되지 않음을 알 수 있음!
      //   });
      //   // bubble phase에 수행되는 이벤트 리스너

      //   _ip.addEventListener('click', ()=>{
      //     console.log(_idx + ' capture phase: input click event occured!');
      //   }, true); // capture phase에 수행되는 이벤트 리스너
      //   // true -> 캡쳐 페이즈에서 수행된다는 것을 암시!
      // });
      // inputs.forEach((_ip, _idx)=>{
      //   _ip.addEventListener('click', ()=>{
      //     console.log(_idx + ' bubble phase : second event listner, click event occured!');
      //   }); // false 생략 -> 버블 페이즈에서 수행되는 리스너
      // });
      
      // // event listner about div
      // const divs = document.querySelectorAll('div');
      // divs.forEach((_dv, _idx)=>{
      //   _dv.addEventListener('click', ()=>{
      //     console.log(_idx + ' bubble phase : div event occured!!');
      //   });

      //   _dv.addEventListener('click', ()=>{
      //     console.log(_idx + ' capture phase : div event occured!!');
      //   }, true);
      // });

      // capture -> target -> bubble phase
      // capture phase
      // 찾으면 target phase!
      // div - div - input - div - div, capture phase를 역방향으로! -> event bubble phase
      // 공기 방울이 위로 떠오른다는 것에서 이름 착안!
      // eventlistener -> bubble phase 시점에 수행! 그래서 역순으로 호출됨


      // 이러한 이벤트 시스템에 대해 알고 있을 필요가 있음!
      // APP or GUI 개발할 때 이러한 구조를 가짐!
      // 다른 시스템의 이벤트를 더 쉽게 이해할 수 있게 됨!
      // 대부분의 이벤트는 버블 페이즈로 처리


      // propagation : 전달
      // event propagation stop!
      
    </script>
  </body>
</html>

