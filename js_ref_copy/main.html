<!-- Copy

1. Shallow Copy
2. Deep Copy

위 개념은 자바스크립트 뿐 아니라 다른 고급 언어에도 포함되는 개념


Reference -->

<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <script>
      // // Copy!!
      // let a = 1;
      // let b = a;
      // // 메모리를 할당받아 값을 갖든지, 아니면 a의 값이 있는 메모리를 공유하든지!
      // // primitive data type -> 공유하지 않고 복사함!
      // // 즉, b도 1의 값을 가지게 됨
      
      // b = 10;
      
      // console.log(`a is ${a}`);
      // console.log(`b is ${b}`);


      // Reference!
      // 구조체의 확장판, object : key(이름, 속성), value(값)
      // obj는 primitive data type이 아니라서 대입을 할 때 복사가 아닌 참조가 발생!
      // 기존 객체를 가리키는 것, thus reference!
      // const a = {'name': 'alice', 'age':20}; // 객체 리터럴 구문!, 값은 무조건 문자열! value는 뭐든 가능?
      // console.log('before', a);

      // const b = a; // 복사라면 아래의 구문으로 이름이 바뀌지 않았을 것!
      
      // const c = {'name':'john', 'age':21};
      
      // // dot notation
      // b.name = 'tom'; // a에 있는 이름이 tom으로 바뀜!
      // b = c;
      // // 오류 발생! 공간 참조 후 다른 공간을 가리키려고 하기 때문에!
      // bracket notation
      // b['name']

      // 왜 const인데 바꿀 수 있는 걸까? 상수 선언인데!
      // object일 때는 의미가 조금 다름!
      // 같은 공간을 가리키고 있기 때문에 문제 없음!, 다른 공간을 가리키지 않는 한 괜찮.
      // 다른 객체를 가리키고자 하는 경우, 예를 들어 b = c인 경우는 안됨
      // 그러나, 같은 공간을 가리키면 안에 있는 내용을 바꿔도 괜찮음.
      // console.log('after', a);

      // array일땐?
      // const a = [1, 2, 3];
      // const b = a;

      // console.log('before ', a);
      // b[1] = 200; // 얘도 reference에 따라 수행!, 원시 데이터 타입이 아니기 때문에.
      // console.log('after', a);
      // a.forEach((v, idx)=>{
      //   console.log(`${idx} : ${v}`);
      // })

      // shallow copy

      // const a = [1, 2, 3];
      // const b = [...a]; // copy 
      // // 참조가 아닌 각각의 공간을 가짐
      // b[1] = 200;
      // console.log(a, b);
      const a = {
        name:'john',
        age:20,
        address:{
          city:'incheon',
          street:'academy-ro'
        }
      }

      console.log('a: ', a.name, a['age'], a.address.city, a.address.street);
      
      const b = Object.assign({}, a); // 뒤에 있는 모든 속성들을 첫 번째 매개변수(현재는 빈 객체)에 복사해 새로운 객체를 만듦!
      b.name = 'alice';
      b.address.city = 'seoul';
      
      console.log('-----after-----');
      // city는 왜 바뀔까?
      // assign -> 원시 데이터 타입은 복사가 되지만, 그게 아닌 경우(현재 객체 address) 복사가 아닌 참조가 되는 것!
      // 깊은 부분은 복사가 되지 않으므로 shallow copy!!, 어려운 부분은 그냥 reference를 통해 공유함.
      // 모든 부분의 복사는 deep copy!
      console.log('a: ', a.name, a['age'],a.address.city, a.address.street);
      console.log('b: ', b.name, b['age'],b.address.city, b.address.street);
      // 자유성이 굉장히 높음!
      


    </script>
  </body>
</html>